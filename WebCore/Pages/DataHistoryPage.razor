@page "/dataHistory"
@page "/dataHistory/{DaysBack:int}"
@page "/dataHistory/{DaysBack:int}/{Offset:int}"
@using DataHistory
@using DataHandler
@using System.Linq;
@using System.Globalization;
@using System.Drawing;
@using ChartJs.Blazor.Charts
@using ChartJs.Blazor.ChartJS
@using ChartJs.Blazor.ChartJS.Common
@using ChartJs.Blazor.Util
@using ChartJs.Blazor.ChartJS.Common.Properties
@using ChartJs.Blazor.ChartJS.Common.Enums
@using ChartJs.Blazor.ChartJS.Common.Legends
@using ChartJs.Blazor.ChartJS.LineChart
@using ChartJs.Blazor.ChartJS.Common.Time
@using ChartJs.Blazor.ChartJS.Common.Axes
@using ChartJs.Blazor.ChartJS.Common.Axes.Ticks
@inject IJSRuntime jsRuntime
@inject IHistoryRepository repos

<h2>RÃ¼ckblick</h2>
@if (errorMsg == null)
{
    <ChartJsLineChart @ref="_lineChartJs" Config="@_lineChartConfig" Width="600" Height="300" />
}
else
{
    <p>@errorMsg</p>
}

@functions
{
    [Parameter]
    public int DaysBack { get; set; } = 7;
    [Parameter]
    public int Offset { get; set; } = 0;

    private LineConfig _lineChartConfig;
    private ChartJsLineChart _lineChartJs;
    private TimeOptions _timeOptions;
    private LineDataset<TimeTuple<float>> _kesselDataset;
    private LineDataset<TimeTuple<float>> _boilerDataset;
    private LineDataset<TimeTuple<float>> _pufferObenDataset;
    private LineDataset<TimeTuple<float>> _pufferUntenDataset;

    private bool localeChangeWasAttempted = false;

    private string? errorMsg = "Loading..";

    private async Task TryChangeLocale()
    {
        if (localeChangeWasAttempted) return;
        localeChangeWasAttempted = true;

        string localeId = CultureInfo.CurrentCulture.Name;
        var locales = await jsRuntime.GetAvailableLocales();
        bool localeChanged = false;
        if (locales != null && locales.Contains(localeId))
        {
            localeChanged = await jsRuntime.ChangeLocale(localeId);
        }

        if (!localeChanged) Console.WriteLine($"Locale was not changed to {localeId}. Either it already is {localeId} or this locale doesn't exist.");
    }

    protected override void OnInitialized()
    {
        bool historyAvailable = repos != null;
        if (historyAvailable) SetupChart();
        else errorMsg = "Es wurde keine History konfiguriert.";
    }

    private void SetupChart()
    {
        _lineChartConfig = GetConfig();

        Func<Data, DateTime>? keySelectorGroupBy = null;
        if (DaysBack <= 2)
        {
            keySelectorGroupBy = null;
        }
        else if (DaysBack >= 100)
        {
            // more than 100 days should only display days
            keySelectorGroupBy = d => new DateTime(d.DatumZeit.Year, d.DatumZeit.Month, d.DatumZeit.Day, 0, 0, 0);
        }
        else if (DaysBack >= 30)
        {
            int roundUpInterval;
            if (DaysBack >= 75)
            {
                roundUpInterval = 10;
            }
            else if (DaysBack >= 50)
            {
                roundUpInterval = 5;
            }
            else
            {
                roundUpInterval = 2;
            }
            // TODO: hours are just rounded to an interval and then clamped between 0-23 so it's not actual 'every x hours', this needs to be fixed somehow
            keySelectorGroupBy = d => new DateTime(d.DatumZeit.Year, d.DatumZeit.Month, d.DatumZeit.Day, d.DatumZeit.Hour.RoundToNext(roundUpInterval).Clamp(0, 23), 0, 0);
        }
        else // still more than 2
        {
            keySelectorGroupBy = d => new DateTime(d.DatumZeit.Year, d.DatumZeit.Month, d.DatumZeit.Day, d.DatumZeit.Hour, 0, 0);
        }

        DateTime now = DateTime.Now;
        if (Offset > 0)
        {
            now = now.AddDays(-1 * Offset);
        }

        // get the data of the days we want
        IQueryable<Data> data = repos.GetDataBetween(now.AddDays(-1 * DaysBack), now);

        var actualData = data
            // TODO check if this can be improved and if the current way has significant downsides (performance wise)
            // we can't do this because our group by selector is stored in a variable and you can't use an annonymous type there
            //.Select(d => new    // only takes those columns that are required
            //{
            //    d.DatumZeit,
            //    d.Kessel,
            //    d.Boiler_1,
            //    d.Puffer_Oben,
            //    d.Puffer_Unten
            //})
            .AsEnumerable();    // from here on, use client-side eval

        if (keySelectorGroupBy == null)
        {
            // we can afford taking all the rows for 2 (or less) days
            actualData = actualData.ToList();

            // more detailed options for this little time
            _timeOptions = new TimeOptions
            {
                Unit = TimeMeasurement.Minute,
                Round = TimeMeasurement.Minute,
                TooltipFormat = "DD.MM.YYYY HH:mm:ss",
                DisplayFormats = TimeDisplayFormats.DE_CH,
                IsoWeek = true
            };
        }
        else
        {
            // load into memory by filtering in client side
            actualData = actualData
                .GroupBy(keySelectorGroupBy)
                .Select(g => g.First())
                .ToList();

            _timeOptions = new TimeOptions
            {
                Unit = TimeMeasurement.Hour,
                Round = TimeMeasurement.Hour,
                TooltipFormat = "DD.MM.YYYY HH:mm",
                DisplayFormats = TimeDisplayFormats.DE_CH,
                IsoWeek = true
            };
        }

        SetupDatasets();

        _pufferObenDataset.AddRange(actualData.Select(d => new TimeTuple<float>((Moment)d.DatumZeit, d.Puffer_Oben ?? -1)));
        _boilerDataset.AddRange(actualData.Select(d => new TimeTuple<float>((Moment)d.DatumZeit, d.Boiler_1 ?? -1)));
        _kesselDataset.AddRange(actualData.Select(d => new TimeTuple<float>((Moment)d.DatumZeit, d.Kessel ?? -1)));
        _pufferUntenDataset.AddRange(actualData.Select(d => new TimeTuple<float>((Moment)d.DatumZeit, d.Puffer_Unten ?? -1)));

        errorMsg = null;
    }

    private LineConfig GetConfig() => new LineConfig
    {
        Options = new LineOptions
        {
            Responsive = true,
            Title = new OptionsTitle
            {
                Display = true,
                Text = "Data history"
            },
            Legend = new Legend
            {
                Position = Position.Right,
                Labels = new LegendLabelConfiguration
                {
                    UsePointStyle = true
                }
            },
            Tooltips = new Tooltips
            {
                Mode = InteractionMode.Nearest,
                Intersect = false
            },
            Scales = new Scales
            {
                xAxes = new List<CartesianAxis>
                {
                    new TimeAxis
                    {
                        Distribution = TimeDistribution.Linear,
                        Ticks = new TimeTicks
                        {
                            Source = TickSource.Data
                        },
                        Time = _timeOptions,
                        ScaleLabel = new ScaleLabel
                        {
                            LabelString = "Zeit"
                        }
                    }
                }
            },
            Hover = new LineOptionsHover
            {
                Intersect = true,
                Mode = InteractionMode.Y
            }
        }
    };

    private void SetupDatasets()
    {
        _kesselDataset = new LineDataset<TimeTuple<float>>
        {
            BackgroundColor = ColorUtil.FromDrawingColor(Color.Orange),
            BorderColor = ColorUtil.FromDrawingColor(Color.Orange),
            Label = "Kessel",
            Fill = false,
            BorderWidth = 2,
            PointRadius = 1,
            PointBorderWidth = 1,
            SteppedLine = SteppedLine.False
        };

        _boilerDataset = new LineDataset<TimeTuple<float>>
        {
            BackgroundColor = ColorUtil.FromDrawingColor(Color.DarkRed),
            BorderColor = ColorUtil.FromDrawingColor(Color.DarkRed),
            Label = "Boiler",
            Fill = false,
            BorderWidth = 2,
            PointRadius = 1,
            PointBorderWidth = 1,
            SteppedLine = SteppedLine.False
        };

        _pufferObenDataset = new LineDataset<TimeTuple<float>>
        {
            BackgroundColor = ColorUtil.FromDrawingColor(Color.Blue),
            BorderColor = ColorUtil.FromDrawingColor(Color.Blue),
            Label = "Puffer Oben",
            Fill = false,
            BorderWidth = 2,
            PointRadius = 1,
            PointBorderWidth = 1,
            SteppedLine = SteppedLine.False,
            Hidden = true
        };

        _pufferUntenDataset = new LineDataset<TimeTuple<float>>
        {
            BackgroundColor = ColorUtil.FromDrawingColor(Color.LightBlue),
            BorderColor = ColorUtil.FromDrawingColor(Color.LightBlue),
            Label = "Puffer Unten",
            Fill = false,
            BorderWidth = 2,
            PointRadius = 1,
            PointBorderWidth = 1,
            SteppedLine = SteppedLine.False,
            Hidden = true
        };

        _lineChartConfig.Data.Datasets.Add(_kesselDataset);
        _lineChartConfig.Data.Datasets.Add(_boilerDataset);
        _lineChartConfig.Data.Datasets.Add(_pufferObenDataset);
        _lineChartConfig.Data.Datasets.Add(_pufferUntenDataset);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender) await TryChangeLocale();
    }
}
